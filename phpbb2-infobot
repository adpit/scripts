#!/usr/bin/perl -w

# this script logins to forum and repeatedly searches for new posts
# mentioning itself, looking for commands, e.g.: "infobot, cariin
# gambar kucing".
#
# if a command is found, it will try to reply to the same topic with
# the answer.

use strict;

use DBI;
use Data::Dumper;
use File::Slurp;
use List::Util qw(shuffle);
use Log::Log4perl qw(:easy);
use URI::Escape;
use WWW::Google::Images;
use WWW::Mechanize;

our $VERSION = '0.1003261';

use App::Options (
    option => {
        # general settings
        profile => { type => 'string', required => 0, default => 'default', },
        log_level => { type => 'string', required => 0, default => 'DEBUG' },

        # forum settings
        username => { type => 'string', required => 1, },
        password => { type => 'string', required => 1, },
        base_url => { type => 'string', required => 1, },

        # bot settings
        botname => { type => 'string', required => 1, description => 'bot name(s), separate with comma for multiple names' },
        delay => { type => 'int', required => 1, default => 30, },
        post_delay => { type => 'int', required => 1, default => 4, },
        db_path => { type => 'string', required => 1, default => "$ENV{HOME}/phpbb2-infobot.db", },
    },
);

my $Mech = new WWW::Mechanize;
my $GI = new WWW::Google::Images;
my $Db;

my $Botname_Regex = join "|", split /,\s*/, $App::options{botname};
$Botname_Regex = qr/(?:$Botname_Regex)/i;
DEBUG "Botname_Regex=$Botname_Regex";

my @Responses = (

    {pat => qr/^\s*$/,
     name => 'EMPTY',
     handler => sub {
         pick("ya um?",
              "ada apa pak?",
              "kenapa bu?",
              "hadir pak!",
              "yup?",
          );
     }},

    # empty, tapi panggilan sayang
    {pat => qr/^(honey|hani|hon|sayang|chayank|say|darling|baby|babe|beibeh|beib)$/,
     name => 'EMPTY',
     handler => sub {
         pick("ya honey?",
              "ada apa say?",
              "kenapa baby?",
              "hadir hon!",
              "yup darling?",
              "iya sayang...",
          );
     }},

    {pat => qr/^(thanks|tx|thx|tq|tenkyu|thank you|makasih|te?rima ?kasih|trm ksh|xie-xie|xie2)$/,
     name => 'THANKS',
     handler => sub {
         pick("sama2x say :))",
              "u're welcome ;)",
              "seim2x :)",
              "no problem",
              "sip...",
              "it's oke :)...",
              "my pleasure...",
              "kembali :)",
          );
     }},

    {pat => qr/^status(-?(ka)?mu)?$/,
     name => 'STATUS',
     handler => sub {
         pick("single",
              "masih jomlo nih",
              "janda beranak satu",
              "baru putus",
              "available",
          ) . "\n\nkidding :)\n\n" .
              sprintf("Real status: Uptime: %.1f jam, Versi skrip: %s, Host: %s, User: %s, PID: %d, Database path: %s",
                      (time - $^T) / 3600, $VERSION, ($ENV{HOSTNAME} || "?"), $ENV{USER}, $$, $App::options{db_path});
     }},

    {pat => qr/^(?:tampil|cari|tonjol|tongol|muncul|ambil|liat)(?:in|kan)\s+(\d+\s+)?(?:(?:buah|biji|bh|bj)\s+)?(?:gambar|gbr|ph?oto|foto|pict?|picture|pikcer|image|imej)\s+(.+)$/i,
     name => 'SEARCH IMAGE',
     handler => sub {
         my (%args) = @_;
         my $res;
         eval {
             $res = $GI->search($args{match}[2],
                                min_size => 25,
                                max_size => 150,
                                limit => 10,
                            );
         };
         if ($@) { return "lagi gak bisa ngakses gugel imejes nih kayaknya han ..." }
         my @im;
         while (my $im = $res->next) { $im = $im->content_url; push @im, $im unless $im =~ /[%?]/ } # phpbb2 sucks!
         @im = shuffle @im;
         my $n = $args{match}[1] || 1;
         splice @im, $n;
         if (@im) {
             return join("", map {"[img]".$_."[/img]\n\n"} @im);
         } else {
             return "gak dapet say :(";
         }
     }},

    {pat => qr/^(\S+)\s*(\+\+|--)\s*(?:\((.*)\))?$/i,
     name => 'KARMA GIVE',
     handler => sub {
         my (%args) = @_;
         my ($username, $to, $karma) = ($args{cmd}{username}, $args{match}[1], $args{match}[2]);
         if ($username eq $to && $karma eq '++') {
             return pick(
                 "yee... ga aci ah say",
                 "yee...",
                 "maaf, tidak diperbolehkan say...",
                 "nunggu dikasih org dong say...",
                 "ferplei dong say...",
                 "sportip dong say...",
             );
         }
         my $url = join('',
                        "$App::options{base_url}/karma.php?mode=give",
                        "&from=".uri_escape($username),
                        "&to=".uri_escape($to),
                        "&reason=".uri_escape($args{match}[3] || ""),
                        "&ref=".uri_escape("ua=$0, post_id=$args{cmd}{post_id}, topic_id=$args{cmd}{topic_id}"),
                        "&karma=".($karma eq '++' ? 1 : -1),
                    );
         $Mech->get($url);
         if ($Mech->content =~ /^((?:SUCCESS|ERROR): .*)/m) {
             my $resp = $1;
             my $extra = "";
             if ($resp =~ /^SUCCESS/) {
                 if ($args{match}[1] =~ /^$Botname_Regex$/) {
                     $extra = "\n\n" . ($karma eq '++' ? "tenkyu btw say :)" : "hiks... tapi gpp say :)");
                 } else {
                     # some evilness
                     $extra = "\n\n" . pick(
                         "rasain!",
                         "hihihihihi...",
                         #"puas...",
                         #"emang enak...",
                         "nah loh?!",
                         "cakiiiitttt!",
                         "peliiihhhh!",
                         "ouch!",
                         #"mati lu!",
                         "gaswat nih...",
                         #"mampus lu!",
                         #"wakakakakak...",
                         "hehehehehe...",
                         #"eug siah...",
                         #"modar koe...", # kasar gak sih?
                     ) if $karma eq '--';
                     # biar balance deh
                     $extra = "\n\n" . pick(
                         "aseeeek!",
                         "traktir traktir...",
                         "wah enak...",
                         "makan makan :)",
                         "wuihhhhh...",
                         "seeepppp say...",
                     ) if $karma eq '++';
                 }
             }
             return $resp . $extra;
         } else {
             return "gagal say :(";
         }
     }},

    {pat => qr/^karma\s+(?:dari|oleh)\s+(\S+)$/i,
     name => 'KARMA GIVING LIST',
     handler => sub {
         my (%args) = @_;
         my $u = $args{match}[1];
         $u = $args{cmd}{username} if $u =~ /^(guah?|gw|gueh?|saya|sy|aku|abang)$/i;
         my $url = join('',
                        "$App::options{base_url}/karma.php?mode=list&from=",
                        uri_escape($u),
                    );
         $Mech->get($url);
         if ($Mech->content =~ /^(.*karma.*:.*)/ms) {
             return $1;
         } else {
             return "gagal say :(";
         }
     }},

    {pat => qr/^karma(?:s|-?nya)?(?:\s+(\S+))?$/i,
     name => 'KARMA LIST',
     handler => sub {
         my (%args) = @_;
         my $u = $args{match}[1];
         $u = $args{cmd}{username} if $u =~ /^(guah?|gw|gueh?|saya|sy|aku|abang)$/i;
         my $url = join('',
                        "$App::options{base_url}/karma.php?mode=list",
                        ($args{match}[1] ? "&user=".uri_escape($u) : ''),
                    );
         $Mech->get($url);
         if ($Mech->content =~ /^(.*karma.*:.*)/ms) {
             return $1;
         } else {
             return "gagal han :(";
         }
     }},

    {pat => qr//,
     name => 'DEFAULT',
     handler => sub {
         pick("maaf say, aq kagak ngerti perintahnya nih",
              "maaf han, q agak belet, bisa diulang perintahnya?",
              "what??",
              "gak ngerti say...",
              "au ah gelap",
              "'paan c???",
              "entahlah.",
              "bodo",
              "(pura-pura gak denger...)",
              "???",
              "maksudnya apa niccch???",
              "o gitu... tapi maksudnya apa yaaaa?",
              "ngerti ngerti ... tapi maksudnya apa yaaaa?",
              "ic ic ... tapi maksudnya apa yaaaa?",
          );
     }},
);

if ( $App::options{log_level} eq 'FATAL' ) {
    Log::Log4perl->easy_init($FATAL);
}
elsif ( $App::options{log_level} eq 'ERROR' ) {
    Log::Log4perl->easy_init($ERROR);
}
elsif ( $App::options{log_level} eq 'WARN' ) {
    Log::Log4perl->easy_init($WARN);
}
elsif ( $App::options{log_level} eq 'INFO' ) {
    Log::Log4perl->easy_init($INFO);
}
else { Log::Log4perl->easy_init($DEBUG) }

INFO "Starting infobot $App::options{botname} ...";

init_db();
login();
while (1) {
    find_new_commands();
    for (unreplied_commands()) {
        respond_command($_);
    }
    sleep $App::options{delay};
}

sub init_db {
    $Db = DBI->connect("dbi:SQLite:dbname=$App::options{db_path}", "", "", {RaiseError=>1});
    $Db->do("CREATE TABLE IF NOT EXISTS cmds (
               id INTEGER PRIMARY KEY AUTOINCREMENT,
               post_id INTEGER NOT NULL,
               username TEXT NOT NULL,
               forum_id INTEGER NOT NULL,
               topic_id INTEGER NOT NULL,
               ctime BIGINT NOT NULL,
               status TEXT NOT NULL DEFAULT 'new',
               raw_command TEXT NOT NULL,
               note TEXT)");
}

sub respond_command {
    my ($cmd) = @_;
    INFO "Parsing command: $cmd->{raw_command} ...";
    for my $r (@Responses) {
        if ($cmd->{raw_command} =~ $r->{pat}) {
            INFO "Command matches $r->{name}";
            my $resp = $r->{handler}->(r=>$r, match=>[$0, $1, $2, $3, $4, $5, $6, $7, $8, $9], cmd=>$cmd);
            forum_post(forum_id=>$cmd->{forum_id}, topic_id=>$cmd->{topic_id},
                       bbcode=>1,
                       message => "[quote=\"$cmd->{username}\"]".$cmd->{raw_command}."[/quote]\n\n".$resp);
            $Db->do("UPDATE cmds SET status='replied' WHERE id=?", {}, $cmd->{id});
            return;
        }
    }
    LOGDIE "Command not handled: $cmd->{raw_command}";
}

sub unreplied_commands {
    my @res;
    my $sth = $Db->prepare("SELECT * FROM cmds WHERE status='new' ORDER by ctime");
    $sth->execute;
    while (my $row = $sth->fetchrow_hashref) { push @res, $row }
    $sth->finish;
    @res;
}

sub find_new_commands {
    # search one-day worth of posts (well, only 1st page) mentioning me
    my $n = join "+", split /,\s*/, $App::options{botname};
    $Mech->get(join "",
               "$App::options{base_url}/search.php?mode=results",
               "&search_keywords=$n",
               "&search_terms=all&search_forum=-1&search_time=1&search_cat=-1&sort_by=0",
               "&show_results=posts&return_chars=200");
    my $ct = $Mech->content;
    $ct =~ s/.+>Search found (\d+) match(?:es)?<//s or do {
        ERROR "Can't parse search result page, skipping";
        return;
    };
    my $now = time;
    while ($ct =~ m!<a href="profile.php\?mode=viewprofile&amp;u=(\d+)">([^>]+)</a>.+?<a href="viewforum.php\?f=(\d+)" class="postdetails">.+?<a href="viewtopic.php\?p=(\d+)&!sg) {
        my ($uid, $username, $forum_id, $post_id) = ($1, $2, $3, $4);
        next if $Db->selectrow_array("SELECT id FROM cmds WHERE post_id=$post_id");
        $Mech->get("$App::options{base_url}/viewtopic.php?p=$post_id");
        $Mech->content =~ /<a class="maintitle" href="viewtopic.php\?t=(\d+)&/ or do {
            ERROR "Can't get topic ID for post #$post_id, skipped";
            next;
        };
        my $topic_id = $1;
        $Mech->content =~ m!<a name="$post_id">.+?<span class="postbody">(.+?)</span><span class="gensmall">!s or do {
            ERROR "Can't grab message body ID for post #$post_id, skipped";
            next;
        };
        my $message = $1;
        for ($message) {
            s!<br />!\n!g;
            s!<td class="quote">.+</td>!!sg;
            s!\012?\015\012?!\n!g;
            s!<[^>]+>!!sg;
        }
        my @cmds;
        while ($message =~ /^$Botname_Regex\s*[:,]\s*(\b.*?)(?:[.?!]+)?$/mg) {
            push @cmds, $1;
        }
        @cmds = grep { $_ eq '' || /\w/ } @cmds;
        next unless @cmds;
        if (@cmds > 5) {
            WARN "Too many commands (".scalar(@cmds).", will only process 5";
            splice @cmds, 5;
        }
        DEBUG "Found command(s) in post #$post_id: " . join(", ", map {"'$_'"} @cmds);
        DEBUG "Message is (quotes cleaned): $message";
        for (@cmds) {
            $Db->do("INSERT INTO cmds (post_id, ctime, forum_id, topic_id, username, raw_command) VALUES (?, ?, ?, ?, ?, ?)", {},
                    $post_id, $now, $forum_id, $topic_id, $username, $_);
        }
    }
}

sub login {
    INFO "Logging in to forum $App::options{base_url} ...";
    $Mech->get("$App::options{base_url}/login.php");
    $Mech->submit_form(
        form_number => 1,
        fields      => {
            username => $App::options{username},
            password => $App::options{password},
        },
        button => 'login',
    );
    #print $Mech->content();
}

sub forum_post {
    my (%args) = @_;

    INFO "Posting to forum (forum #$args{forum_id}".($args{topic_id} ? ", topic #$args{topic_id}" : "").") ...";

    # get new posting form
    $Mech->get(
        $args{topic_id}
        ? "$App::options{base_url}/posting.php?mode=reply&t=$args{topic_id}"
        : "$App::options{base_url}/posting.php?mode=newtopic&f=$args{forum_id}"
    );

    if ($args{obfuscate_link}) {
        $args{message} =~ s!\bhttp(s?)://!hxxp$1://!ig;
    }

    #DEBUG "posting = $posting";
    $Mech->submit_form(
        form_number => 1,
        fields      => {
            subject         => $args{subject} || "Re:",
            message         => $args{message},
            disable_html    => "on",
            disable_bbcode  => ($args{bbcode} ? "off" : "on"),
            disable_smilies => "on",
        },
        button => 'post',
    );

    #print $Mech->content;

    unless ( $Mech->content =~ /successfully/i ) {
        ERROR "Failed posting!";
    }
    sleep $App::options{post_delay};
}

sub pick {
    $_[rand @_];
}

#!/usr/bin/perl -w

use 5.010;
use autodie;
use strict;
use Cwd 'abs_path';
use File::chdir;
use Log::Log4perl qw(:easy);
#use String::ShellQuote; #sementara pakai 'foo' doang

Log::Log4perl->easy_init($TRACE);
#Log::Log4perl->easy_init($INFO);

my $src;
my $dest;
my @wanted_repos;

my $cmd;

if (@ARGV == 0) {
    $src = "$ENV{HOME}/repo";
    $dest = "$ENV{HOME}/he/repo";

    if ($0 =~ /[2-]builder/) {
        $dest = "$ENV{HOME}/hb/repo";
    } elsif ($0 =~ /[2-]eddie/) {
        $dest = "$ENV{HOME}/he/repo";
    } elsif ($0 =~ /[2-]capuchin/) {
        $dest = "$ENV{HOME}/hc/repo";
    } elsif ($0 =~ /[2-]backpacker/) {
        $dest = "$ENV{HOME}/repo-backpacker";
    }

    if ($0 =~ /2home$/) {
        ($src, $dest) = ($dest, $src);
    }
} elsif (@ARGV >= 2) {
    $src = shift @ARGV;
    $dest = shift @ARGV;
    @wanted_repos = @ARGV;
} else {
    die "Usage: $0 <src> <dest> [repo ...]\n";
}

(-d $src)  or die "src dir `$src` not exist or not a dir\n";
$src = abs_path($src);
(-d $dest) or die "dest dir `$dest` not exist or not a dir\n";
$dest = abs_path($dest);

chdir $src;
my @src_repos = grep {-d} <*>;

chdir $dest;
for my $repo (@src_repos) {
    next if @wanted_repos && !($repo ~~ @wanted_repos);
    INFO "Processing repo `$repo` ...";
    unless (-d $repo) {
        if (-e $repo) {
            FATAL "Repo `$repo` is not a dir? skipped";
            next;
        }
        mysystem("cp -a '$src'/$repo .");
        if (($? & 255) != 0) {
            FATAL "Can't successfully copy repo `$repo` from $src: $?";
        } else {
            INFO "Repo `$repo` copied";
        }
        next;
    }
    sync_repo($src, $dest, $repo);
}

sub sync_repo {
    my ($src, $dest, $repo) = @_;
    my $exit;

    my @src_branches;
    my @dest_branches;

    chdir "$src/$repo";
    @src_branches = map {(/^[* ] (.+)/, $1)[-1]} myqx("LANG=C git branch");
    $exit = $? & 255;
    if ($exit) {
        FATAL "Can't list branches on src repo `$src`: $?";
        die;
    }
    DEBUG "src branches: ".join(", ", @src_branches);

    chdir "$dest/$repo";
    @dest_branches = map {(/^[* ] (.+)/, $1)[-1]} myqx("LANG=C git branch");
    if ($exit) {
        FATAL "Can't list branches on dest repo `$repo`: $?";
        die;
    }
    DEBUG "dest branches: ".join(", ", @dest_branches);

    my $output;
    for my $branch (@src_branches) {
        if (@src_branches > 1) {
            INFO "Updating branch `$branch` ...";
            my $make_branch = ($branch ~~ @dest_branches) ? "" : "git branch '$branch'; ";
            $output = myqx("cd '$src/$repo'; git checkout '$branch'; cd '$dest/$repo'; ${make_branch}git checkout '$branch'; LANG=C git pull '$src/$repo' '$branch' 2>&1 && cd '$src'");
        }
        $exit = $? & 255;
        if ($exit == 0 && $output =~ /Already up-to-date/) {
            DEBUG "Repo `$repo` is up to date, nothing to do";
        } elsif ($output =~ /^error: (.+)/m) {
            FATAL "Can't successfully pull: $1";
            die;
        } elsif ($exit == 0 && $output =~ /^Updating |^Merge made by recursive/m) {
            INFO "Repo `$repo` updated";
        } else {
            FATAL "Can't figure out result of 'git pull' for repo `$repo`: exit=$exit, output=$output";
            die;
        }
        DEBUG "Result of 'git pull' for repo `$repo`: exit=$exit, output=$output";
    }

}

sub mysystem {
    INFO "system(): ".join(" ", @_);
    system @_;
}

sub myqx {
    my $cmd = shift;
    INFO "qx(): $cmd";
    `$cmd`
}

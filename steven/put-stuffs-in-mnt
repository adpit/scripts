#!/usr/bin/ruby

# 2004-12-25 - memastikan bahwa apa yg harus diencrypt (karena
# sifatnya private/rahasia) harus ditaruh di /mnt.

LOG_LEVEL = 3
VERBOSE = 0
OVERWRITE = 1 # when both exist, delete stuff in /mnt/ and move the unmnt to mnt

require 'pathname'
require 'fileutils'

# mv -nya gak berjalan dengan benar? atau gw harusnya pake mv FILE
# /OTHER/FILE instead of just mv FILE /OTHER/ ?
#include FileUtils

class String
  def escapeshellarg
    "'" + (self.gsub(/'/) {|s| "'"+'"'+"'"+'"'+"'"}) + "'"
  end

  alias_method :esc, :escapeshellarg
end

module Kernel
  alias_method :orig_system, :system

  def system(cmd, *args)
    puts "system: #{cmd} #{args.join ' '}"
    orig_system(cmd, *args) # or raise SystemCommandError, "#{$?}"
  end
end

def verbose1(msg); puts "VERBOSE1: "+msg if VERBOSE >= 1 end

def debug(msg); puts "DEBUG: "+msg if LOG_LEVEL >= 5 end
def info (msg); puts "INFO: " +msg if LOG_LEVEL >= 4 end
def warn (msg); puts "WARN: " +msg if LOG_LEVEL >= 3 end
def error(msg); puts "ERROR: "+msg if LOG_LEVEL >= 2 end
def fatal(msg); puts "FATAL: "+msg if LOG_LEVEL >= 1; exit 1 end

def realpath(p)
  Pathname.new(p).realpath.to_s
end

def basename(p)
  Pathname.new(p).basename.to_s
end

def dirname(p)
  Pathname.new(p).dirname.to_s
end

def in_mnt(p)
  rp = realpath(p)
  result = rp =~ %r(^/mnt/) ? true : false
  debug "in_mnt: p=#{p}, realpath(p)=#{rp}, result=#{result}"
  result
end

# move /some/path to /mnt/some/path and make /some/path symlink
# to /mnt/some/path

def move_dir_to_mnt(dir)
  verbose1 "Processing directory: #{dir}..."
  targetparentdir = "/mnt#{dirname dir}"

  unless dir =~ %r(^/)
    error "INTERNAL ERROR: #{dir} doesn't start with a slash, skipped. " +
      "Please check my source code for errors."
    return
  end
  if dir =~ %r(/$)
    error "INTERNAL ERROR: #{dir} ends with, skipped. " +
      "Please check my source code for errors."
    return
  end
  if !FileTest.exists?(dir) && !FileTest.exists?("/mnt#{dir}")
    warn "Both #{dir} and /mnt#{dir} don't exist, skipped"
    return
  end
  if FileTest.exists?(dir) && !FileTest.directory?(dir)
    error "#{dir} is not a directory, skipped"
    return
  end

  if FileTest.symlink?(dir) && in_mnt(File.readlink(dir))
    info "#{dir} is already symlinked to /mnt, skipped"
    return
  end
  if (FileTest.exists?(dir) && !in_mnt(dir))
    info "#{dir} is not in /mnt, moving..."
    if FileTest.exists? "/mnt#{dir}"
      if OVERWRITE
        system "rm -rf /mnt#{dir}"
      else
        warn "/mnt#{dir} and #{dir} exist, skipped. " +
          "You should probably delete #{dir} first."
        return
      end
    end
    system "mkdir -p #{targetparentdir.esc}"
    system "mv #{dir.esc} #{targetparentdir.esc}/"
  end

  if FileTest.exists?(dir) || !FileTest.exists?("/mnt#{dir}")
    error "#{dir} still exists or /mnt#{dir} doesn't exist, skipped. " +
      "You should probably check this situation."
    return
  end

  system %Q(ln -s #{"/mnt#{dir}".esc} #{dir.esc})
end

def move_file_to_mnt(file)
  verbose1 "Processing file: #{file}..."
  targetparentdir = "/mnt#{dirname file}"

  unless file =~ %r(^/)
    error "INTERNAL ERROR: #{file} doesn't start with a slash, skipped. " +
      "Please check my source code for errors."
    return
  end
  if file =~ %r(/$)
    error "INTERNAL ERROR: #{file} ends with, skipped. " +
      "Please check my source code for errors."
    return
  end
  if !FileTest.exists?(file) && !FileTest.exists?("/mnt#{file}")
    warn "Both #{file} and /mnt#{file} don't exist, skipped"
    return
  end
  if FileTest.exists?(file) && FileTest.directory?(file)
    error "#{file} is a directory, skipped"
    return
  end

  if FileTest.symlink?(file) && in_mnt(File.readlink(file))
    info "#{file} is already symlinked to /mnt, skipped"
    return
  end
  if (FileTest.exists?(file) && !in_mnt(file))
    info "#{file} is not in /mnt, moving..."
    if FileTest.exists? "/mnt#{file}"
      if OVERWRITE
        system "rm -f /mnt#{file}"
      else
        warn "/mnt#{file} and #{file} exist, skipped. " +
          "You should probably delete #{file} first."
        return
      end
    end
    system "mkdir -p #{targetparentdir.esc}"
    system "mv #{file.esc} #{targetparentdir.esc}"
  end

  if FileTest.exists?(file) || !FileTest.exists?("/mnt#{file}")
    error "#{file} still exists or /mnt#{file} doesn't exist, skipped. " +
      "You should probably check this situation."
    return
  end

  system %Q(ln -s #{"/mnt#{file}".esc} #{file.esc})
end

# --- main

fatal "/mnt is not mounted" unless 
  %x(/bin/mount) =~ %r(/dev/mapper/.+ on /mnt)

raise RunTimeError, "Please run me as root" unless
  Process.uid == 0

# home dirs
move_dir_to_mnt "/home/sloki/user/steven/home"
move_dir_to_mnt "/home/sloki/user/steven/sites/steven.builder.localdomain/syslog"
#move_dir_to_mnt "/home/sloki/user/steven/sites/traps.steven.builder.localdomain/syslog"
move_dir_to_mnt "/home/sloki/user/test1/home"
move_dir_to_mnt "/home/sloki/user/test2/home"
move_dir_to_mnt "/home/sloki/user/test3/home"
move_dir_to_mnt "/home/sloki/user/stats/home"
move_dir_to_mnt "/home/sloki/user/mwn/home"

# /root
move_dir_to_mnt "/root/Desktop"
# -- all dotfiles
Dir.chdir "/root"
dirs = []; files = []
Dir[".*"].each {|e|
  next if e == '.' || e == '..'
  (FileTest.directory?(e) ? dirs : files) << "/root/#{e}"
}
dirs.each  {|d| move_dir_to_mnt d}
files.each {|f| move_file_to_mnt f}

# squid
move_dir_to_mnt "/var/log/squid"
move_dir_to_mnt "/var/spool/squid"

# slocate
#move_dir_to_mnt "/var/cache/locate" # ini kalau belum instal paket 'slocate'
move_dir_to_mnt "/var/lib/slocate"

# ftp
Dir["/var/log/xferlog*"].each { |f| move_file_to_mnt f }

# samba
move_dir_to_mnt "/var/log/samba"

# XXX slk-smtpd's logs? (/var/log/slk-smtpd and
# /var/spool/slk-smtpd). in the mean time, ngirim email private pakai
# web saja...

# NOTE: /mnt/usr/bin/manipurlation gak ada symlinknya

# dnscache & tinydns
#move_dir_to_mnt "/etc/dnscache/log"
#move_dir_to_mnt "/etc/tinydns/log"

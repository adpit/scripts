#!/usr/bin/perl -w

# todo:

# 1. notes

# 2. thumbnail can be zoomed when clicked (use jquery), display
# semi-enlarged image + list of tags (clickable) + title + several
# images before + several images after (prev + next link)

use autodie;
use strict;
use Cwd qw(abs_path);
use DateTime;
use File::Slurp;
use HTML::Entities 'encode_entities';
use Image::Size;
use Log::Log4perl qw(:easy);
use Statistics::Descriptive;
use YAML;

use App::Options (
    option => {
        #overwrite => { type => 'boolean', required => 0, default => 0, },
        clean_html => { type => 'boolean', required => 0, default => 0, },
        photo_dir => { type => 'string', require => 1, default => '.', },
        meta_dir => { type => 'string', require => 0, }, # default = {photo_dir}
        log_level => { type => 'string', required => 0, default => 'INFO' },
    },
);

eval { require GD; import GD; };
my $GD_Available = $@ ? 0:1;

if (!defined($App::options{meta_dir})) { $App::options{meta_dir} = $App::options{photo_dir} }

if ( $App::options{log_level} eq 'FATAL' ) {
    Log::Log4perl->easy_init($FATAL);
}
elsif ( $App::options{log_level} eq 'ERROR' ) {
    Log::Log4perl->easy_init($ERROR);
}
elsif ( $App::options{log_level} eq 'WARN' ) {
    Log::Log4perl->easy_init($WARN);
}
elsif ( $App::options{log_level} eq 'INFO' ) {
    Log::Log4perl->easy_init($INFO);
}
else { Log::Log4perl->easy_init($DEBUG) }

DEBUG "Opening meta file ($App::options{meta_dir}/meta.yaml) ...";
my $meta = Load(scalar read_file "$App::options{meta_dir}/meta.yaml");

DEBUG "Processing photo dir ($App::options{photo_dir}) ...";
chdir $App::options{photo_dir};

if ($App::options{clean_html}) {
    no autodie;
    unlink "index.html", <tag_*.html>, <note_*.html>;
    exit 0;
}

my @images = sort { lc($a) cmp lc($b) } (<*.jpg>, <*.JPG>);
INFO "Generating thumbnails ...";
system "mkdir -p .tn";
for my $filename (@images) {
    my $tnname = tnname($filename);
    unless (-s $tnname) {
        my $filesize = (-s $filename)/1024;
        my ($x, $y) = imgsize($filename);
        my $x2 = 120; my $y2 = int($y/$x*$x2);
        INFO "Generating thumbnail $tnname ...";
        if ($GD_Available) {
            my $image = GD::Image->newFromJpeg($filename);
            my $image2 = GD::Image->new($x2, $y2);
            $image2->copyResized($image, 0, 0, 0, 0, $x2, $y2, $x, $y);
            write_file $tnname, $image2->png;
        } else {
            system qq(convert "$filename" -resize ${x2}x$y2 "$tnname");
        }
    }
}

INFO "Generating tag pages ...";
my %tag_images;
for my $img (keys %{ $meta->{images} }) {
    my $v = $meta->{images}{$img};
    my $tags = $v->{tags};
    for my $tag0 (@$tags) {
        my ($prefix, $tag1);
        if ($tag0 =~ /([^:]+):(.+)/) {
            $prefix = $1; $tag1 = $2;
        } else {
            $prefix = ""; $tag1 = $tag0;
        }
        my $tag2 = "";
        for my $t (reverse split m!/!, $tag1) {
            $tag2 = $t . (length($tag2) ? "/" : "") . $tag2;
            my $tag = (length($prefix) ? "$prefix:" : "") . $tag2;
            $tag_images{$tag} //= [];
            push @{ $tag_images{$tag} }, $img;
        }
    }
}
# XXX sort images in each tag
for my $tag (keys %tag_images) {
    INFO "Generating tag page: $tag ...";
    my $n = scalar(@{ $tag_images{$tag} });
    open F, ">" . tags_filename($tag); # XXX how to handle conflict if there are two tags with the same filename, e.g. foo: & foo, -> foo_
    print F "<html><title>".encode_entities($tag)." ($n)</title>\n";
    print F "<h1>".encode_entities($tag)." ($n)</h1>\n";
    print F (tn_html($tag_images{$tag}));
    print F "</html>\n";
    close F;
}

#INFO "Generating note pages ...";
#if ($meta->{notes}) {
#    my $i = 0;
#    for (@{ $meta->{notes} }) {
#        $i++;
#        DEBUG "";
#        my $v = $meta->{images}{$img};
#        my $tags = $v->{tags};
#        for my $tag (@$tags) {
#            my $ftag = "";
#            for my $t (split m!/!, $tag) {
#                $ftag .= $t;
#                $tag_images->{$ftag} //= [];
#                push @{ $tag_images->{$ftag} }, $img;
#            }
#        }
#    }
#}
# XXX sort images in each tag
#for my $tag (keys %tag_images) {
#    INFO "Generating note page: $tag ...";
#    my $n = scalar(@{ $tag_images->{$tag} });
#    open F, ">" . tags_filename($tag); # XXX how to handle conflict if there are two tags with the same filename, e.g. foo: & foo, -> foo_
#    print F "<html><title>".encode_entities($tag)." ($n)</title>\n";
#    print F "<h1>".encode_entities($tag)." ($n)</h1>\n";
#    print F tn_html($tag_images->{$tag});
#    print F "</html>\n";
#    close F;
#}

INFO "Generating index page ...";
my $photo_dir = abs_path("."); $photo_dir =~ s!.*/!!;
my $album_title = $meta->{album_title} // $photo_dir;
open F, ">index.html";
print F "<html><head><title>".encode_entities($album_title)."</title>\n";

print F "</head>\n<body>\n";
print F "<h1>".encode_entities($album_title)."</h1>\n";

print F "<h2>All tags (".scalar(keys %tag_images).")</h2>\n";
my $stat = Statistics::Descriptive::Full->new;
$stat->add_data(map { scalar @{ $tag_images{$_} } } keys %tag_images);
DEBUG "\$stat->add_data(".join(", ", map { scalar @{ $tag_images{$_} } } keys %tag_images).")";

# doesn't give what i want? so i'll use quantile for the moment
#my $f = $stat->frequency_distribution_ref(7);
#DEBUG "\$f = { ".join(", ", map {"$_ => $f->{$_}"} sort keys %$f)." }";
#my @nums = reverse sort keys %$f;
#my @sizes = qw(small medium medium medium large x-large xx-large);

my @nums = map {$stat->quantile($_)} 0..4;
my @sizes = qw(small medium large x-large xx-large);

DEBUG "\@nums = ".join(", ", @nums);
my $i = 0;
for (sort keys %tag_images) {
    my $num = scalar(@{ $tag_images{$_} });
    my $size = $sizes[0];
    for my $j (1..@nums) {
        if ($num >= $nums[@nums-$j]) { $size = $sizes[@nums-$j]; last }
    }
    print F "\n, " if $i++;
    print F "<span style=\"font-size: $size\"><a href=".tags_filename($_).">$_</a> ($num)</span>";
}

print F "<h2>All images (".scalar(@images).")</h2>\n";
print F (tn_html(\@images));

print F "</body>\n";
print F "</html>\n";
close F;

sub filename_esc {
    my ($str) = @_;
    $str =~ s/\W+/_/g;
    $str;
}

sub tnname {
    my ($img) = @_;
    my $tnname = $img;
    $tnname =~ s/\.jpg$//i;
    $tnname .= ".png";
    ".tn/$tnname";
}

sub tags_filename {
    my ($tag) = @_;
    "tag_" . filename_esc($tag) . ".html";
}

sub tn_html {
    my ($imgs) = @_;
    my $res = "<table cellpadding=3>\n";
    my $col = 0;
    for (@$imgs) {
        $col = 0 if $col++ == 5;
        $res .= "<tr>\n" if $col == 1;
        my $title = "";
        if (my $m = $meta->{images}{$_}) {
            if (length $m->{title}) {
                $title = $m->{title};
            } elsif (@{ $m->{tags} }) {
                $title = "Tags: ".join(", ", @{ $m->{tags} });
            }
        }
        $res .= "<td><a href=$_><img border=0 src=".tnname($_).
            " title=\"".encode_entities($title)."\"></a><br>$_</td>\n";
        $res .= "</tr>\n" if $col == 0;
    }
    $res .= "</tr>\n" unless $col == 0;
    $res .= "</table>\n";
    $res;
}

sub notes_filename {
    my ($i) = @_;
    "note_$i.html";
}


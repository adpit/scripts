#!/usr/bin/perl

# this script connects to mysql and then run continuously, polling processlist
# periodically (by default every minute). the goal is to help mysql keep
# accepting connections and answering to queries. sometimes under high load
# there will be lots of Locked queries etc and/or the number of processes are
# nearing/reaching maximum. under that condition the script can be instructed to
# kill some queries or restart mysql.

# TODO: a generic app might be: configuration: list of conditions and criteria,
# e.g. suffocating = 5+x in a row, >98% full processes. locked = 3+x in a row,
# locked >10% and >75% full. configuration: map of condition to strategy/remedy:
# e.g. suffocating -> restart, locked -> kill locked process (selectively). the
# configuration can be packaged and installed (e.g.
# spanel-sustain-mysql-policy-whmcs_myisam) because it's tuned to specific
# application/condition.
#
# processlist data should be generated by spanel stats and can be
# provided/supplied for this. can be mocked for testing.

use 5.010;
use strict;
use warnings;
use Log::Any::App '$log';

BEGIN {
    our $IS_DAEMON = 0; # Log::Any::App mistook our using Proc::PID::File as being a daemon
    our $File_Log_Level = 'debug';
}

#use DateTime;
use Data::Unixish::List qw(dux);
use DBI;
use Dir::Purge;
use File::Slurp;
use Proc::PID::File;

# VARS
my $DUMP_DIR = "/var/lib/statdump";
my $PS_DUMP_DIR = "/var/lib/statdump/mysql-pslist";
# XXX TO CONFIG. when suffocating, try to find queries to kill, in order. if
# first element's queries are found, try killing that first and see how it goes.
# if suffocates again, still try the first element's queries. if not found, then
# try the second element's and so on.
my @KILL_QUERY_CRITERIAS = (
    {query => qr/select \s+ count\(\*\) \s+ from \s+ tblhosting \s+ where \s+ server='\d+'/ix},
    {query => qr/select \s+ count\(\*\) \s+ from \s+ tbltickets \s+ where \s+ `?userid`?=/ix},
    #{state => 'Locked'},
);
# END VARS

die "This script is meant to run as root" if $>;
do { $log->trace("Program is already running, exiting"); exit 1 }
    if Proc::PID::File->running(verify=>1);

# get pass from ~/my.cnf
my ($pass) = ~~read_file("$ENV{HOME}/.my.cnf") =~ /^password\s*=\s*(.+)/m;

sub _connect {
    DBI->connect("DBI:mysql:database=mysql", "root", $pass, {RaiseError=>1});
}
my $dbh = _connect();

my $row;
$row = $dbh->selectrow_hashref("SHOW VARIABLES WHERE Variable_name='max_connections'");
my $maxconn = $row->{Value};
$log->debugf("max_connections = %d", $maxconn);

for ($DUMP_DIR, $PS_DUMP_DIR) { mkdir $_, 0700 unless (-d $_) }

my $iter = 0;
my $times_suffocating = 0;
ITER:
while (1) {
    my @now = gmtime();

    $log->tracef("Performing SHOW FULL PROCESSLIST ...");
    my @ps;
    my $sth = $dbh->prepare("SHOW FULL PROCESSLIST");
    $sth->execute;
    while (my @row = $sth->fetchrow_array) {
        $row[7] =~ s/[\t\r\n]+/ /g if $row[7];
        push @ps, \@row;
    }

    if ($iter % 5 == 0) {
        my $path = sprintf("%s/%04d-%02d-%02dT%02d:%02d:%02dZ", $PS_DUMP_DIR, $now[5]+1900, $now[4]+1, $now[3], $now[2], $now[1], $now[0]);
        $log->infof("Dumping processlist to %s ...", $path);
        write_file($path, join("", map {join("\t", map {$_//""} @$_)."\n"} @ps));
        purgedir(1440, $PS_DUMP_DIR); # 1440 x 5 minute = 5 days, like in spanel
    }

    my $num_locked = 0; for (@ps) { $num_locked++ if (($_->[6]//"") eq 'Locked') }
    my $pct_full   = @ps / $maxconn * 100;
    my $pct_locked = $num_locked / $maxconn * 100;
    my $avg_query_time = dux('avg', map {$_->[5]} grep {$_->[4] eq 'Query'} @ps);
    $log->debugf("processes=%d (%.1f%% full), locked=%d (%.1f%%), avg_query_time=%.1fs", ~~@ps, $pct_full, $num_locked, $pct_locked, $avg_query_time);
    if ($pct_full >= 90 && $pct_locked > 25 || $pct_full >= 97) {
        $times_suffocating++;
        $log->info("This is suffocating ...");
    } else {
        $times_suffocating = 0;
    }

    if ($times_suffocating >= 5) {
        $log->warn("Has been suffocating several times in a row, restarting MySQL ...");
        system "/etc/init.d/mysql restart";
        sleep 5;
        $dbh = _connect();
        $times_suffocating = 0;
        redo ITER;
    }

    if ($times_suffocating >= 3 && 0) {
        $log->warn("Has been suffocating several times in a row, finding processes to kill");

        my @kill;
        for my $crit (@KILL_QUERY_CRITERIAS) {
            for (@ps) {
                if ($crit->{query}) {
                    next unless $_->[4] eq 'Query' && $_->[7] ~~ $crit->{query};
                }
                if ($crit->{state}) {
                    next unless $_->[6] ~~ $crit->{state};
                }
                push @kill, $_;
            }
        }

        if (@kill) {
            for (@kill) {
                $log->infof("Killing query %s ...", $_);
                $dbh->do("KILL $_->[0]");
            }
            sleep 1;
            $times_suffocating = 0;
            redo ITER;
        } else {
            $log->warn("Currently can't kill any more processes");
        }
    }

    sleep 60;
    $iter++;
}

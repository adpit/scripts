#!/usr/bin/perl -w

use 5.010;
use autodie;
use strict;

use App::Options (
    option => {
        profile    => { type => 'string', required => 0, default => 'default', },
        log_level  => { type => 'string', required => 0, default => 'DEBUG', },
        src        => { type => 'string', required => 1,
                        default => "$ENV{HOME}/repos" },
        dest       => { type => 'string', required => 1, },
        rsync_dot_dirs => {
            type => 'boolean', required => 0, default => 1,
            description => 'do one-way rsync for dot directories (i usually '.
                'put old data here, these directories are currently not git '.
                'repos)',
        },
        wanted_repos => {
            type => 'string', required => 0, default => '',
            description => 'comma-separated list of wanted repos, '.
                'empty means all',
        },
        delete     => {
            type => 'boolean', required => 0, default => 0,
            description => 'whether to delete branches in dest repo '.
                'not existing in src repo',
        },
        lock => {
            type => 'boolean', required => 0, default => 1,
            description => 'if set to false, delete .git/index.lock first '.
                'before pulling (if you do this, make sure no other process '.
                'is acting on your repository)',
        },
    },
);

use Cwd 'abs_path';
use File::chdir;
use Log::Log4perl qw(:easy);
#use String::ShellQuote; #sementara pakai 'foo' dulu aja deh

my $l = $App::options{log_level};
$l = $l eq 'FATAL' ? $FATAL :
    ($l eq 'ERROR' ? $ERROR :
         ($l eq 'WARN' ? $WARN :
              ($l eq 'INFO' ? $INFO :
                   ($l eq 'DEBUG' ? $DEBUG :
                        ($l eq 'TRACE' ? $TRACE :
                             $DEBUG)))));
Log::Log4perl->easy_init($l);

my $src = $App::options{src};
my $dest = $App::options{dest};

my $cmd;

(-d $src)  or die "src dir `$src` not exist or not a dir\n";
$src = abs_path($src);
(-d $dest) or mkdir $dest;
$dest = abs_path($dest);
my @wanted_repos;
@wanted_repos = split(/,\s*/, $App::options{wanted_repos})
    if length($App::options{wanted_repos});

chdir $src;
my @src_repos = grep {-d} <*>;

$CWD = $dest;

rsync_dot_dirs($src, $dest) if $App::options{rsync_dot_dirs};

for my $repo (@src_repos) {
    next if @wanted_repos && !($repo ~~ @wanted_repos);
    INFO "Processing repo `$repo` ...";
    unless (-d $repo) {
        if (-e $repo) {
            FATAL "Repo `$repo` is not a dir? skipped";
            next;
        }
        mysystem("cp -a '$src'/$repo .");
        if (($? & 255) != 0) {
            FATAL "Can't successfully copy repo `$repo` from $src: $?";
        } else {
            INFO "Repo `$repo` copied";
        }
        next;
    }
    sync_repo($src, $dest, $repo);
}

sub rsync_dot_dirs {
    INFO "Processing dot directories ...";
    mysystem("rsync -az '$src'/.??* '$dest'/");
}

sub sync_repo {
    my ($src, $dest, $repo) = @_;
    my $exit;

    my @src_branches;
    my @dest_branches;
    my %src_heads; # last revisions for each branch
    my %dest_heads; # last revisions for each branch

    local $CWD = "$src/$repo";
    @src_branches = map {(/^[* ] (.+)/, $1)[-1]} myqx("LANG=C git branch");
    $exit = $? & 255;
    if ($exit) {
        FATAL "  Can't list branches on src repo `$src/$repo`: $?";
        die;
    }
    DEBUG "  src branches: ".join(", ", @src_branches);
    for my $branch (@src_branches) {
        my $output = myqx("LANG=C git log -1 '$branch'");
        $exit = $? & 255;
        if ($exit) {
            FATAL "  Can't find out head for branch `$branch` on src repo `$src/$repo`: $?";
            die;
        }
        $output =~ /commit (\S+)/ or do {
            FATAL "  Can't recognize git log output (searching for commit XXX): $output";
            die;
        };
        $src_heads{$branch} = $1;
    }
    DEBUG "  src branch heads: ".join(", ", map {"$_ => $src_heads{$_}"} keys %src_heads);

    $CWD = "$dest/$repo";
    @dest_branches = map {(/^[* ] (.+)/, $1)[-1]} myqx("LANG=C git branch");
    if ($exit) {
        FATAL "  Can't list branches on dest repo `$repo/$repo`: $?";
        die;
    }
    DEBUG "  dest branches: ".join(", ", @dest_branches);
    for my $branch (@dest_branches) {
        my $output = myqx("LANG=C git log -1 '$branch'");
        $exit = $? & 255;
        if ($exit) {
            FATAL "  Can't find out head for branch `$branch` on dest repo `$dest/$repo`: $?";
            die;
        }
        $output =~ /commit (\S+)/ or do {
            FATAL "  Can't recognize git log output (searching for commit XXX): $output";
            die;
        };
        $dest_heads{$branch} = $1;
    }
    DEBUG "  dest branch heads: ".join(", ", map {"$_ => $dest_heads{$_}"} keys %dest_heads);

    my $output;
    my $lock_deleted;
    for my $branch (@src_branches) {
        # XXX we should allow fetching tags only even if head is the same, but
        # right now tags are not that important
        if ($src_heads{$branch} && $dest_heads{$branch} &&
                $src_heads{$branch} eq $dest_heads{$branch}) {
            DEBUG "  Skipping branch `$branch` because head already the same";
            next;
        }
        if (!$App::options{lock} && !$lock_deleted++) {
            DEBUG "Deleting locks first ...";
            no autodie;
            unlink "$src/$repo/.git/index.lock";
            unlink "$dest/$repo/.git/index.lock";
        }
        DEBUG "  Updating branch `$branch` ..." if @src_branches > 1;
        $output = myqx("cd '$dest/$repo'; ".
                       ($branch ~~ @dest_branches ? "":"git branch '$branch'; ").
                       "git checkout '$branch' 2>/dev/null; ".
                       "LANG=C git pull '$src/$repo' '$branch' 2>&1");
        $exit = $? & 255;
        if ($exit == 0 && $output =~ /Already up-to-date/) {
            DEBUG "  Branch `$branch` is up to date, nothing to do";
        } elsif ($output =~ /^error: (.+)/m) {
            FATAL "  Can't successfully git pull branch `$branch`: $1";
            die;
        } elsif ($exit == 0 &&
                     $output =~ /^Updating |^Merge made by recursive/m) {
            INFO "  Branch `$branch` updated" if @src_branches > 1;
            INFO "  Repo `$repo` updated"     if @src_branches == 1;
        } else {
            FATAL "  Can't figure out result of 'git pull' for ".
                "branch `$branch`: exit=$exit, output=$output";
            die;
        }
        DEBUG "  Result of 'git pull' for branch `$branch`: ".
            "exit=$exit, output=$output";

        $output = myqx("cd '$dest/$repo'; ".
                       "LANG=C git fetch --tags '$src/$repo' 2>&1");
        $exit = $? & 255;
        if ($exit != 0) {
            FATAL "  Can't successfully fetch --tags: $output (exit=$exit)";
            die;
        }

    }

    if ($App::options{delete}) {
        for my $branch (@dest_branches) {
            next if $branch ~~ @src_branches;
            next if $branch eq 'master'; # can't delete master branch
            INFO "  Deleting branch `$branch` because it no longer exists ".
                "in src ...";
            mysystem("cd '$dest/$repo' && git checkout master 2>/dev/null && ".
                     "git branch -D '$branch' 2>/dev/null");
            if (($? & 255) != 0) {
                ERROR "  Can't successfully delete branch `$branch`: $?";
            }
        }
    }
}

sub mysystem {
    DEBUG "system(): ".join(" ", @_);
    system @_;
}

sub myqx {
    my $cmd = shift;
    DEBUG "qx(): $cmd";
    `$cmd`
}

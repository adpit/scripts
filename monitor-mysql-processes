#!/usr/bin/perl

# run continuously, periodically (by default every minute) polls. try to kill
# Locked thread if after 3 minutes in a row in a "suffocating" state (90%+ full,
# 25%+ locked).

use 5.010;
use strict;
use warnings;
use Log::Any::App '$log';

BEGIN {
    our $IS_DAEMON = 0; # Log::Any::App mistook our using Proc::PID::File as being a daemon
    our $File_Log_Level = 'debug';
}

#use DateTime;
use Data::Unixish::List qw(dux);
use DBI;
use Dir::Purge;
use File::Slurp;
use Proc::PID::File;

# VARS
my $DUMP_DIR = "/var/lib/statdump";
my $PS_DUMP_DIR = "/var/lib/statdump/mysql-pslist";
# XXX TO CONFIG. when suffocating, try to find queries to kill, in order. if
# first element's queries are found, try killing that first and see how it goes.
# if suffocates again, still try the first element's queries. if not found, then
# try the second element's and so on.
my @KILL_QUERY_REGEXES = (
    qr/select \s+ count\(\*\) \s+ from \s+ tblhosting \s+ where \s+ server='\d+'/ix,
);
# END VARS

die "This script is meant to run as root" if $>;
do { $log->trace("Program is already running, exiting"); exit 1 }
    if Proc::PID::File->running(verify=>1);

# get pass from ~/my.cnf
my ($pass) = ~~read_file("$ENV{HOME}/.my.cnf") =~ /^password\s*=\s*(.+)/m;
my $dbh = DBI->connect("DBI:mysql:database=mysql", "root", $pass, {RaiseError=>1});

my $row;
$row = $dbh->selectrow_hashref("SHOW VARIABLES WHERE Variable_name='max_connections'");
my $maxconn = $row->{Value};
$log->debugf("max_connections = %d", $maxconn);

for ($DUMP_DIR, $PS_DUMP_DIR) { mkdir $_, 0700 unless (-d $_) }

my $iter = 0;
my $times_suffocating = 0;
ITER:
while (1) {
    my @now = gmtime();

    $log->tracef("Performing SHOW FULL PROCESSLIST ...");
    my @ps;
    my $sth = $dbh->prepare("SHOW FULL PROCESSLIST");
    $sth->execute;
    while (my @row = $sth->fetchrow_array) {
        $row[7] =~ s/[\t\r\n]+/ /g if $row[7];
        push @ps, \@row;
    }

    if ($iter % 5 == 0) {
        my $path = sprintf("%s/%04d-%02d-%02dT%02d:%02d:%02dZ", $PS_DUMP_DIR, $now[5]+1900, $now[4]+1, $now[3], $now[2], $now[1], $now[0]);
        $log->infof("Dumping processlist to %s ...", $path);
        write_file($path, join("", map {join("\t", map {$_//""} @$_)."\n"} @ps));
        purgedir(1440, $PS_DUMP_DIR); # 1440 x 5 minute = 5 days, like in spanel
    }

    my $num_locked = 0; for (@ps) { $num_locked++ if (($_->[6]//"") eq 'Locked') }
    my $pct_full   = @ps / $maxconn * 100;
    my $pct_locked = $num_locked / $maxconn * 100;
    my $avg_query_time = dux('avg', map {$_->[5]} grep {$_->[4] eq 'Query'} @ps);
    $log->debugf("processes=%d (%.1f%% full), locked=%d (%.1f%%), avg_query_time=%.1fs", ~~@ps, $pct_full, $num_locked, $pct_locked, $avg_query_time);
    if ($pct_full >= 90 && $pct_locked > 25 || $pct_full >= 97) {
        $times_suffocating++;
        $log->info("This is suffocating ...");
    } else {
        $times_suffocating = 0;
    }

    if ($times_suffocating >= 3) {
            $log->warn("Has been suffocating several times in a row, finding processes to kill");
        my @locked_pids = map { $_->[0] } grep { $_->[6] eq 'Locked' } @ps;
        if (@locked_pids) {
            $log->warn("Killing locked processes (%s) ...", \@locked_pids);
            $dbh->do("KILL $_") for @locked_pids;
            sleep 1;
            $times_suffocating = 0;
            redo ITER;
        } else {
            $log->debug("There are no locked processes on the server");
            for my $re (@KILL_QUERY_REGEXES) {
                my @query_pids = map { $_->[0] } grep { $_->[4] eq 'Query' && $_->[7] =~ /($re)/ } @ps;
                if (@query_pids) {
                    $log->info("Killing running queries matching %s (%s) ...", $re, \@query_pids);
                    $dbh->do("KILL $_") for @locked_pids;
                    sleep 1;
                    $times_suffocating = 0;
                    redo ITER;
                }
            }
            $log->warn("Currently can't kill any more processes");
        }
    }

    sleep 60;
    $iter++;
}
